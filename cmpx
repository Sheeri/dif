#!/home/utils/perl-5.8.8/bin/perl
use warnings;
use strict;
use Cwd;
use Data::Dumper;
use File::Basename;
use File::Temp qw/ tempfile tempdir /;
use Getopt::Long;
sub say { print @_, "\n" }

# Debugger
sub D { say "Debug::Statements has been disabled to improve performance" }
sub d { }
#eval 'use lib "/home/ate/scripts/regression";  use Debug::Statements ":all";'; say "\nRemember to comment the Debug::Statements line before checking in the code !!\n";
#use lib "/home/ate/scripts/regression";
#use Debug::Statements ":all";

# Defaults
my %default;
$default{head} = 10000;                                                 # lines printed by -head
$default{fold} = 105;                                                   # columns used by -fold
$default{bcpp} = "/usr/bin/bcpp";
$default{bcpp} = "/home/ckoknat/cs2/linux/bcpp -s -bcl -tbcl -ylcnc" if -d "/home/ckoknat";
$default{perltidy} = "$^X" . "tidy -l=110 -ce";

my $scriptName = basename($0);
sub usage {
    say "\n
'$scriptName' by Chris Koknat

Purpose:
    When comparing large text files on Linux, the graphical compare tools
    gvimdiff, kompare, or meld are often used.
    In many cases, it is difficult to compare the files directly,
    when each file needs to be preprocessed before comparing.
    
    This script runs the Linux gvimdiff, kompare, or meld tool on 2 files
    after preprocessing each of them with a wide variety of options.

Sample Problems and Solutions:
    Problem:    Differences in whitespace or comments or case cause mismatches
    Solution:   Use options -white or -nowhite or -comments or -case

    Problem:    Input files are too large for a quick comparison
    Solution1:  Use -head or -tail to only compare the first or last N lines
                or
    Solution2:  Use -start and -stop to specify a section of the file using regexes

    Problem:    Lines are too long to visually compare easily
    Solution:   Use -fold to wrap

    Problem:    Files contain binary characters
    Solution:   Use -strings

    Problem:    Files are sorted differently
    Solution:   Use -sort

    Problem:    Files both need to be filtered using regexes, to strip out certain characters or sequences
    Solution1:  Use -sub <regex> to supply one instance of substitution and replacement
                or
    Solution2:  Use -subtable <file> to supply a file with many substitution/replacement

Usage examples:
    perl $scriptName file1 file2
    perl $scriptName file1 file2 -white
    perl $scriptName dir1 dir2

Filtering options:    
   -head              compare only the first $default{head} lines
   
   -headlines N       compare only the first N lines.

   -tail              compare only the first $default{head} lines
   
   -taillines N       compare only the first N lines.

   -fields N          compare only fields N.  Multiple fields may be given, separated by commas (-fields N,M).
                      Field numbers start at 0.
                      Fields in the input files are assumed to be separated by spaces, unless the filename ends with .csv (separated by commas)
                      Example:  -fields 2
                      Example:  -fields 0,2      (fields 0 and 2)
                      Example:  -fields -1       (last field)
                      Example:  -fields 2+       (field 2 and onwards)
                      Example:  -fields not2+    (ignore fields 2 and onwards)
                      Example:  -fields not0,5+  (ignore fields 0, 5, and onwards)

   -fieldSeparator regex    Only needed if default field separators above are not sufficient
                            Example:  -fieldSeparator ':'
                            Example:  -fieldSeparator '[,=]' 

   -fieldJustify      make all fields the same width, right-justified

   -white             remove blank lines and leading/trailing whitespace.
                      Condense multiple whitespace to a single space
   
   -nowhite           remove all whitespace.  Useful to check output of perltidy.

   -case              convert files to lowercase before comparing
   
   -split             splits each line on whitespace
   
   -splitchar 'char'  splits each line on 'char'
   
   -trim              Trims each line to $default{fold} characters.
                      Useful when lines are very long, and the important information is near the beginning
   
   -trimchars N       Trims with specified number of characters, instead of $default{fold}
   
   -comments          remove any comments like // or # or single-line */ /*
                      requires module Regexp::Common

   -grep 'regex'      Only keep lines which match the user-specified regex
                      Multiple regexs can be specified, for example:  -grep '(regexA|regexB)'

   -ignore 'regex'    Ignore any lines which match the user-specified regex
                      This is the exact opposite of the -grep function
                      
   -start 'regex'     Start comparing file when line matches regex
   
   -stop 'regex'      Stop comparing file when line matches regex

                      For example, to compare Perl subroutines 'add' and 'subtract'
                      inside files a.pm and b.pm:
                          k a.pm b.pm -start '^sub (add|subtract) ' -stop '^}'

   -start1 -stop1 -start2 -stop2
                      Similar to -start and -stop
                      The '1' and '2' refer the files
                      Enables comparing different sections within the same file, or different sections within different files
                      For example, to compare Perl subroutines 'add' and 'subtract' within a.pm:
                          k a.pm -start1 'sub add' -stop1 '^}' -start2 'sub subtract' -stop '^}'

   -subroutine 'subroutine_name'
                      Compare same subroutine from two source files
                      Subroutines may be Perl (sub {}) or TCL (proc {}{})
                      May specify multiple subroutines with -subroutine '(mysubA|mysubB|mysubC)'
                      Internally, this piggybacks on the -start -stop functionality

   -subroutineSort
                      Useful when Perl subroutines have been moved within a file.
                      This option preprocesses each file, so that the subroutine definitions
                      are in alphabetical order
   
   -sub 'search^^replace'    On each line, do global regex search and replace.
                             The ^^ is the delimiter between the search and replace terms.
                             For example, to replace 'line 1234' with 'line':
                                 -sub 'line \\d+^^line'
                              
                             Since the search term is interpreted as a regex,
                             remember to escape any parentheses
                                 Exception:  if you are using regex grouping, 
                                             do not escape the parentheses.
                                 For example:
                                     -sub '(A|B|C)^^D'

                             Since the replace term is eval'd, make sure to escape any \$ dollar signs
                             Make sure you use 'single-quotes' instead of \"double-quotes\"
                             For example, to convert all spaces to newlines, use:
                                 -sub '\\s+^^\\n'

   -subtable file     Specify a two-column file which will be used for search/replace
                      The delimiter is any amount of spaces
                      Terms in the file are treated as regular expressions
                      The replace term is eval'd

   -tartv             Compare tarfiles using tar -tv, and look at the file size
                      If file size is not desired, also use -fields 1
   
   -lsl               Useful when comparing previously captured output of 'ls -l'
                      Filters out everything except size and filename
      
   -yaml              Used for comparing two yaml files via Data::Dumper
   
   -json              Used for comparing two json files via Data::Dumper

   -perldump          Useful when comparing previously captured output of Data::Dumper
                      filter out all SCALAR/HASH/ARRAY/REF/GLOB/CODE addresses from output of Dumpvalue,
                      since they change on every execution.
                          SPECS' => HASH(0x9880110)    becomes    'SPECS' => HASH()
                      Also works on Python object dumps:
                          <_sre.SRE_Pattern object at 0x216e600>

   -perleval          The input file is a perl hashref
                      Print the keys in alphabetical order

  
Preprocessing options (before filtering):
   -bcpp              Run each input file through bcpp with options:  $default{bcpp}

   -perltidy          Run each input file through perltidy with options:  $default{perltidy}
   
   -externalPreprocessScript <script>          
                    Run each input file through your custom preprocessing script.
                    It must take input from STDIN and send output to STDOUT, similar to unix 'sort'


Postprocessing options (after filtering):
   -sort              run Linux 'sort' on each input file

   -uniq              run Linux 'uniq' on each input file to eliminate duplicated adjacent lines.  Use with -sort to eliminate all duplicates.
   
   -strings           run Linux 'strings' command on each input file

   -fold              run 'fold' on each input file with default of $default{fold} characters per column
                      Useful for comparing long lines,
                      so that you don't need to scroll within the kompare tool

   -foldchars N       run 'fold' on each input file with N characters per column

   -pponly            Stop after creating processed files


Viewing options:
   -silent            Do not print to screen.

   -verbose           Print names of preprocessed files, before comparing

   -stdout            Cat all processed files to stdout

   -difftool cmd      Instead of using gvimdiff to graphically compare the files, use a different tool
                      For example:
                      -difftool diff
                            Prints diff to stdout

                      -difftool gvimdiff
                            Uses gvimdiff as a GUI
                      
                      -difftool kompare
                            Uses kompare as a GUI

                      -difftool meld
                            Uses meld as a GUI

                      -difftool md5sum
                            Prints the m5sum to stdout, after preprocessing

                      -difftool ''          
                            This is useful when comparing from a script
                            After running $scriptName, check the return status:
                                0 = files are equal
                                1 = files are different
                                $scriptName a.yml b.yml difftool '' -silent ; echo \$?

                      -difftool 'diff -C 1' | grep -v '^[*-]'
                          Use diff, with the options:
                              one line of Context above and below the diff
                              remove the line numbers of the diffs

   -diff              Shortcut for '-difftool diff'

   The diff tool can also be set with an environment variable.  For example, use one of these:
       setenv CMPX_DIFFTOOL /usr/bin/meld
       export CMPX_DIFFTOOL=/usr/bin/meld


Other options:
   -gold              When used with one filename (file.extension), assumes that 2nd file will be file.golden.extension
                      When used with multiple filenames (file.extension), it runs $scriptName multiple times, once for each of the pairs.
                      This option is useful when doing regressions against golden files

   -dir2 <dir>        For each input file specified, run 'k' on the file in the current directory against the file in the specified directory
                      For example:
                          k file1 file2 file3 -dir ..
                      will run:
                          k file1 ../file1
                          k file2 ../file2
                          k file3 ../file3
   
  -listfiles         Print report showing which files match, when using -gold or -dir2


Perforce version control support:
        Perforce uses # to signify version numbers
Perforce examples:
        perl $scriptName file#6 file#7   compares p4 version 6 with p4 version 7
        perl $scriptName file#6 file#+   compares p4 version 6 with p4 version 7
        perl $scriptName file#6 file#-   compares p4 version 6 with p4 version 5
        perl $scriptName file#7          compares p4 version 7 with file version
        perl $scriptName file#head       compares most current p4 version with file version
                      
\n";
    exit 0;
}

my $originalCmdLine = "$0 " . join( ' ', @ARGV );
# Parse options
my %opt = (
    # Preprocess
    bcpp                     => '',
    perltidy                 => '',
    externalPreprocessScript => '',
    # Postprocess
    sort      => "",
    uniq      => "",
    strings   => "",
    fold      => "",
    foldchars => 0,
    trim      => "",
    trimchars => 0,
    head      => 0,
    headlines => 0,
    tail      => 0,
    taillines => 0,
    # Filter
    pponly   => 0,
    white    => 0,
    nowhite  => 0,
    case     => 0,
    comments => 0,
    lsl      => 0,
    perldump => 0,
    perleval => 0,
    yaml     => 0,
    json     => 0,
    rp       => 0,
    # Other
    dir2      => '',
    gold      => 0,
    listfiles => 0,
    help      => 0,
    silent    => 0,
    difftool  => undef,
    diff      => 0,
    gvimdiff  => 0,
    tkdiff    => 0,
    kompare   => 0,
    meld      => 0,
    stdout    => 0,
);
my $d = 0;
Getopt::Long::GetOptions( \%opt, 'd' => sub { $d = 1 }, 'dd' => sub { $d = 2 }, 'help|h|?', 'sort|s', 'paragraphSort', 'uniq|u', 'strings', 'fold|f', 'foldchars=s', 'trim', 'trimchars=s', 'head', 'headlines=s', 'tail', 'taillines=s', 'fields=s', 'fieldSeparator=s', 'fieldJustify', 'pponly', 'white|w', 'nowhite', 'case', 'comments', 'grep=s', 'ignore=s', 'start=s', 'stop=s', 'start1=s', 'stop1=s', 'start2=s', 'stop2=s', 'subroutine=s', 'subroutineSort', 'sub=s', 'subtable=s', 'split', 'splitchar=s', 'lsl', 'bcpp', 'perltidy', 'externalPreprocessScript=s', 'perldump', 'perleval', 'yaml|yml', 'json', 'silent', 'verbose|v', 'difftool=s', 'diff', 'gvimdiff|gv', 'tkdiff', 'kompare|k', 'meld|m', 'md5sum', 'stdout', 'rp', 'ps', 'gold|g', 'dir2=s', 'listfiles', 'nodirs', 'tartv' ) or usage();

# Check if files exist
my @files = @ARGV;
usage() if ( $opt{help} or not @files );
$files[0] .= 'ead' if $files[0] =~ /#h$/;    # enable #h instead of #head
$files[1] .= 'ead' if $files[0] =~ /#h$/;    # enable #h instead of #head
d '%opt @files';
my $windows = ( $^O =~ /Win/ ) ? 1 : 0;      # Are we running on Windows?
# To use with Windows, download http://strawberryperl.com and WinMerge.  Windows support is very limited, expect some features to not work

chomp( my $whoami = `whoami` );
if ( $whoami eq 'ckoknat' ) {
    my %scriptsMapping = (
        # Custom shortcuts for my commonly edited files
        # Same table is used in /home/ckoknat/bin/b and /home/ckoknat/bin/p4f
        CPN        => 'CheckPatternName.pm',
        'CPN.t'    => 'regression/cpn/CPN.t',
        cpn        => 'check_pattern_names.pl',
        'cpn.t'    => 'regression/cpn/cpn.t',
        kpi        => 'kpi.pl',
        misc       => 'CAD/Misc.pm',
        'misc.t'   => 'regression/CAD_Misc.t',
        ps         => 'processStilRev.tn',
        ps2        => 'dftqtracker/processStilRev2.pl',
        pt2        => 'CAD/PatternTracker2.pm',
        'pt2.t'    => 'regression/CAD_PatternTracker2.t',
        ri         => 'dftqtracker/releaseImageRev.pl',
        rp         => 'releasePatternsRev2.pl',
        rp1        => 'releasePatternsRev.pl',
        rp2        => 'releasePatternsRev2.pl',
        scanio     => 'CAD/ScanIo.pm',
        'scanio.t' => 'regression/CAD_ScanIo.t',
        ups        => 'updatePatternState.pl',
        uvl        => 'updateVectorLabel2.pl',
        uvl1       => 'updateVectorLabel.pl',
        uvl2       => 'updateVectorLabel2.pl',
        vlm        => 'perlib/VectorLabelMap.pm',
        web        => 'CAD/Web.pm',
        'web.t'    => 'regression/CAD_Web.t',
    );
    ( my $file = $files[0] ) =~ s/(#.*)//;
    my $p4rev = $1 || '#head';
    if ( defined $scriptsMapping{$file} ) {
        $files[0] = "$scriptsMapping{$file}$p4rev";
    }
}

if ( $opt{split} or defined $opt{splitchar} ) {
    if ( $opt{sub} ) {
        say "ERROR:  Cannot use -sub with -split or -splitchar";
        exit 1;
    } elsif ( $opt{split} ) {
        $opt{sub} = "\\s+^^\\n";
    } elsif ( defined $opt{splitchar} ) {
        my $splitchar = quotemeta( $opt{splitchar} );
        $opt{sub} = "$splitchar^^\\n";
    } else {
        die "Program bug";
    }
}

$opt{start} = $opt{start2} if defined $opt{start2};
$opt{stop}  = $opt{stop2}  if defined $opt{stop2};
$opt{start} = $opt{start1} if defined $opt{start1};
$opt{stop}  = $opt{stop1}  if defined $opt{stop1};
if ( not $files[1] and $opt{start2} ) {
    $files[1] = $files[0];
}

# Sanity check
if ( $opt{subroutine} ) {
    if ( $opt{start} or $opt{stop} ) {
        say "ERROR:  Cannot use -subroutine with -start or -stop";
        exit 1;
    }
    $opt{start} = '^\s*(sub|proc)\s+' . $opt{subroutine} . '\s+{';
    $opt{stop}  = '^}';
}


# Decide which diff tool to use
chomp( my $uid = `whoami` );
my $difftool = 'gvimdiff';
if ( defined $opt{difftool} ) {
    $difftool = $opt{difftool};
} elsif ( $opt{diff} ) {
    $difftool = 'diff';
} elsif ( $opt{gvimdiff} ) {
    $difftool = 'gvimdiff';
} elsif ( $opt{tkdiff} ) {
    $difftool = '/home/utils/tkdiff-4.2/bin/tkdiff';
} elsif ( $opt{kompare} ) {
    $difftool = 'kompare';
} elsif ( $opt{meld} ) {
    $difftool = 'meld';
} elsif ( $opt{md5sum} ) {
    $difftool = 'md5sum';
} elsif ( defined $ENV{CMPX_DIFFTOOL} ) {
    # Options must supercede this
    $difftool = $ENV{CMPX_DIFFTOOL};
} else {
    # Custom user defaults if no diff tool was chosen
    my $executable_regex = '.(c|cpp|h|pl|pm|py|tn|tcl)($|#)';
    if ( $uid =~ /astehle/ ) {
        $difftool = 'meld';
    } elsif ( $uid =~ /ckoknat/ ) {
        if ( defined $files[2] or defined $files[1] and $opt{gold} ) {
            # Meld seems to have issues with many files
            $difftool = 'kompare';
        } elsif ( $files[0] =~ /$executable_regex/ ) {
            $difftool = 'kompare';
        } else {
            #$difftool = 'meld'; # Tired of meld 1.8.6 crashing
            $difftool = 'kompare';
        }
    } elsif ( $uid =~ /jcolburn|samgao/ ) {
        $difftool = 'tkdiff';
    }
}
d '$difftool';

# Customizations based on difftool choice
if ( $difftool =~ /kompare|meld/ ) {
    # Use gvimdiff instead of kompare once the file goes above a limit
    #     10MB uncompressed file takes 2 seconds on gvimdiff vs 39 seconds on kompare and similar on meld (meld will open but not show differences for a while)
    #     Need to test this on meld as well
    my $sizelimit;
    if ( $files[0] =~ /\.(gz|zip|bz2|xz)$/ ) {
        $sizelimit = 1000000;
    } else {
        $sizelimit = 3000000;
    }
    if ( -e $files[0] and -s $files[0] > $sizelimit ) {
        # Using -e because don't want to run these checks if run with p4 revs:  k releasePatternsRev.pl#136 #140
        say "Switching to gvimdiff to speed up comparison because 1st file is > $sizelimit bytes.  If you really want to use $difftool, use option '-difftool $difftool'" unless $opt{silent};
        $difftool = 'gvimdiff';
    } else {
        # do nothing
    }
}
d '$difftool';
# Cannot combine this with the above code, since we may have switched to gvimdiff
if ( $difftool =~ /gvimdiff/ ) {
    $default{fold} = 80;    # columns used by -fold, gvimdiff uses larger font than kompare
} elsif ( $difftool eq 'meld' ) {
    my $meld;
    my $meld_161 = "/home/utils/meld-1.6.1/bin/meld";
    my $meld_186 = "/home/utils/meld-1.8.6/bin/meld";
    # meld does not have line numbers (unless install python-gtksourceview2 is installed)
    # in that case, use kompare instead
    if ( -f $meld_186 ) {
        $meld = $meld_186;
    } elsif ( -f $meld_161 ) {
        $meld = $meld_161;
    } elsif ( -f '/usr/bin/meld' ) {
        $meld = '/usr/bin/meld';
    } else {
        say "WARNING:  meld not found.  Using kompare instead";
        $meld = 'kompare';
    }
    $difftool = $meld;
    # meld $default{fold} is same as for kompare
}
d '$difftool';
# Fall back to gvimdiff if kompare is not installed
if ( $difftool ne '' ) {
    # $difftool might be 'diff -C 3'
    ( my $difftool_executable = $difftool ) =~ s/^(\S+).*/$1/;
    my $result = `which $difftool_executable`;
    if ( $result eq '' ) {
        say "Using gvimdiff since $difftool_executable is not installed" unless $opt{silent};
        # sudo apt install kompare
        $difftool = 'gvimdiff';
    }
}
if ($windows) {
    #$difftool = "fc.exe";  # like diff
    $difftool = "start WinMerge";    # Need to install from internet
}

# Decide if file needs to go through the preprocessing code
# If not, then we can later do a quick md5sum check to determine equality
my $preprocessRequired = 0;
$preprocessRequired = 1 if $opt{sort} or $opt{paragraphSort} or $opt{uniq} or $opt{strings} or $opt{fold} or $opt{foldchars} or $opt{trim} or $opt{trimchars} or $opt{head} or $opt{headlines} or $opt{tail} or $opt{taillines} or defined $opt{fields} or $opt{fieldJustify} or $opt{white} or $opt{nowhite} or $opt{case} or $opt{comments} or defined $opt{grep} or defined $opt{ignore} or defined $opt{start} or defined $opt{stop} or defined $opt{sub} or $opt{subtable} or $opt{subroutineSort} or $opt{lsl} or $opt{perltidy} or $opt{externalPreprocessScript} or $opt{perleval} or $opt{yaml} or $opt{json} or $opt{bcpp} or $opt{perldump} or $opt{rp} or $opt{ps};
for my $file (@files) {
    if ( $file =~ /\.tar(\.gz|bz2|xz)?(#(\d+|head|\-|\+))?$/ ) {
        if ( $opt{tartv} ) {
            # do nothing, will be handled later
        } else {
            $preprocessRequired = 1;
            $difftool           = 'gvimdiff';
        }
    }
    if ( $file =~ /#(\d+|head)$/ or $file =~ m{^//} ) { $preprocessRequired = 1 }
    if ( $file =~ /\.gz$/ ) {
        if ( $difftool =~ /(diff|kompare|meld)/ ) {
            $preprocessRequired = 1;
        } elsif ( $difftool eq '' ) {
            $preprocessRequired = 1;
        }    # Avoids "binary files differ"
    }
}
if ( $difftool eq "gvimdiff" and $preprocessRequired ) {
    # Set gvim options to speed up comparison
    # Only for preprocessed files, since the options will prevent reading of compressed files
    $difftool = 'gvimdiff -u NONE -U NONE -N -R +"set number" +"set ic" +"set hlsearch"';
}
d '$preprocessRequired $difftool';

# Setup for uncompression
my @zipExtension = @files;
for my $f (@zipExtension) {
    $f =~ s/^.*(\.(gz|bz2|xz))$/$1/;
    $f = '.gz' if !defined $f;
}
$zipExtension[1] = $zipExtension[0] if !defined $zipExtension[1];    # perforce#NNN without 2nd file
d '@files @zipExtension';
my $zipDiff;
if ( grep { /\.xz/ } @zipExtension ) {
    # Due to bug in xzdiff, which returns status 0 regardless if files differ or not, require preprocessing (unzipping)
    $preprocessRequired = 1;
    $zipDiff            = 'zdiff';
} elsif ( $zipExtension[0] eq $zipExtension[1] ) {
    my %diffref = ( '.gz' => 'zdiff', '.bz2' => 'bzdiff', '.xz' => 'xzdiff' );
    $zipDiff = $diffref{ $zipExtension[0] };
    $zipDiff = 'zdiff' if !$zipDiff;                                 # .txt
} else {
    # Files have different zip formats
    $preprocessRequired = 1;
    $zipDiff            = 'zdiff';
}
d '$zipDiff $preprocessRequired';

$opt{silent} = 1                                                        if $opt{stdout};
$opt{head}   = 99999999999                                              if $opt{head} == 0;
$opt{head}   = $default{head}                                           if $opt{head} == 1;
$opt{head}   = $opt{headlines}                                          if $opt{headlines};
$opt{tail}   = $default{head}                                           if $opt{tail} == 1;
$opt{tail}   = $opt{taillines}                                          if $opt{taillines};
$opt{sort}   = "| sort"                                                 if $opt{sort} ne "";
$opt{sort}   = "| perl -n00 -e 'push \@a, \$_; END { print sort \@a }'" if $opt{paragraphSort};
$opt{uniq}   = "| uniq"                                                 if $opt{uniq} ne "";
if ( $opt{strings} ne "" ) {
    if ( `which strings` eq '' ) {
        # Use perl if 'strings' executable does not exist in linux
        $opt{strings} = "| perl -nle 'print \$& while m/[[:print:]]{4,}/g'";
    } else {
        #$opt{strings} = "| strings";
        $opt{strings} = "| perl -nle 'print \$& while m/[[:print:]]{4,}/g'";
    }
}
if ( $opt{fold} or $opt{foldchars} ) {
    $opt{fold} = $opt{foldchars} ? "| fold -s -w $opt{foldchars}" : "| fold -s -w $default{fold}";
}
if ( $opt{trim} or $opt{trimchars} ) {
    $opt{trim} = $opt{trimchars} ? $opt{trimchars} : $default{fold};
}

my $fieldsNegate = 0;
if ( defined $opt{fields} ) {
    if ( $opt{fields} =~ s/^\!// ) {
        # The '!' gets interpreted by the shell on the command line
        $fieldsNegate = 1;
    }
    if ( $opt{fields} =~ s/^not// ) {
        # workaround for above problem
        $fieldsNegate = 1;
    }
}

# -sub and -subtable
my ( $subtable_ref, @sub_keys_ordered );
$opt{subtable} = "/home/ckoknat/s/regression/rp/ktable.txt" if $opt{rp};    # NV-specific
$opt{subtable} = "/home/ckoknat/s/regression/ps_ktable.txt" if $opt{ps};    # NV-specific
if ( $opt{sub} or $opt{subtable} ) {
    d '$opt{sub}';
    d '$opt{subtable}';
    if ( $opt{sub} ) {
        if ( $opt{sub} =~ /(.+)\^\^(.*)/ ) {
            my ( $search, $replace ) = ( $1, $2 );
            d '$search $replace';
            $subtable_ref = { $search => eval "qq($replace)" };
        } else {
            die "For -sub option, need to have ^^ between search and replace terms\n";
        }
    }
    if ( $opt{subtable} ) {
        $subtable_ref = read_table_file( $opt{subtable}, 0, 1 );            # read_table_file($opt{tablefile},$opt{reverse},$opt{regex})
        d '$subtable_ref';
        if ( !%{$subtable_ref} ) {
            say "ERROR:  Did not find any entries in table file!  Exiting.\n";
            exit 1;
        }
        $opt{sub} = 1;
    }
    @sub_keys_ordered = ( reverse sort { length $a <=> length $b } keys %$subtable_ref );
    d( '@sub_keys_ordered', 'e' );
}

my @files_orig = @files;
if ( $opt{dir2} ) {
    $opt{nodirs} = 1;
}
if ( $opt{nodirs} ) {
    @files = ();
    for my $file (@files_orig) {
        if ( -d $file ) {
            # do nothing
        } else {
            push @files, $file;
        }
    }
}

# If -gold is used, get the golden/non-golden version
# If -dir2 is used, get the file from the other directory
# If more than one file was specified, call k multiple times with options
# k file#123
if ( $opt{gold} and $opt{dir2} ) {
    die "ERROR:  Cannot use -gold with -dir2";
}
if ( $opt{gold} or $opt{dir2} ) {
    if ( $opt{listfiles} ) {
        # This does not work in conjunction with any of the preprocessing options
        # For regression testing
        #     ~/r/k/cmpx -gold file1 file3 file4 file5
        # For as2
        #     cd /home/scratch.ckoknat_cad/ate/hw/nv/nvtools/processStil
        #     ~/r/k/cmpx -dir2 /home/ate/scripts/release/tv5s/a01 * CAD/* dftqtracker/* -listfiles
        say "Option -listfiles compares sets of files (without doing any preprocessing)";
        d '@files';
        my @newfiles;
        if ( $opt{gold} ) {
            for my $file (@files) {
                next if -d $file;
                my ( $goldfile, $position ) = to_from_golden($file);
                if ( $position == 1 ) {
                    push @newfiles, $goldfile;
                    push @newfiles, $file;
                } else {
                    push @newfiles, $file;
                    push @newfiles, $goldfile;
                }
            }
        } elsif ( $opt{dir2} ) {
            for my $file (@files) {
                next if -d $file;
                my $dir2file = to_dir2($file);
                push @newfiles, $file;
                push @newfiles, $dir2file;
            }
        } else {
            die "Program bug";
        }
        d '@newfiles';
        my @mismatches;
        while (@newfiles) {
            my $file1 = shift(@newfiles);
            my $file2 = shift(@newfiles);
            d '$file1 $file2';
            my $status1 = `md5sum $file1 | cut -d ' ' -f 1`;
            my $status2 = `md5sum $file2 | cut -d ' ' -f 1`;
            d '$status1 $status2';
            if ( $status1 ne $status2 ) {
                push @mismatches, "$file1  $file2\n";
            }
        }
        d '@mismatches';
        if (@mismatches) {
            say "Found " . scalar(@mismatches) . " mismatches:\n @mismatches";
            exit 1;
        } else {
            say "All file pairs matches";
            exit 0;
        }
    }
}
if ( $opt{gold} or $opt{dir2} ) {
    if ( scalar @files > 1 ) {
        d '$originalCmdLine';
        $originalCmdLine =~ s/@files_orig//;
        d '$originalCmdLine';
        for my $file (@files) {
            my $cmd = "$originalCmdLine $file &";
            d '$cmd';
            system "$cmd";
        }
        exit 0;
    }
}

sub to_dir2 {
    my $file = shift;
    # Assuming that all files listed are in the current directory or underneath
    # fileA fileB mydir/fileC
    #
    ## dir2 could be absolute or relative
    ## relative:
    ##     file            dir2/file
    ##     mypath/file
    ##     /path/to/file
    ## absolute
    ##     file            /dir2/file
    ##my $path = dirname($file);
    ##my $base = basename($file);
    ##my $dir2file = "$path/$opt{dir2}/$base";
    my $dir2file = "$opt{dir2}/$file";
    return $dir2file;
}

sub to_from_golden {
    my $file = shift;
    my $dir  = dirname($file);
    my ( $goldfile, $position );
    if ( basename($file) =~ /^(.*)\.golden(.*)$/ ) {
        # a.golden     => a
        # a.golden.csv => a.csv
        # returning the NON golden filename
        $goldfile = "$dir/$1$2";
        $position = 2;
    } elsif ( basename($file) =~ /^(.*)(\.[^.]+)$/ ) {
        # a.csv        => a.golden.csv
        # returning the golden filename
        $goldfile = "$dir/$1.golden$2";
        $position = 1;
    } else {
        # a            => a.golden
        # returning the golden filename
        $goldfile = "$file.golden";
        $position = 1;
    }
    return wantarray ? ( $goldfile, $position ) : $goldfile;
}

if ( $opt{gold} ) {
    my ( $goldfile, $position ) = to_from_golden( $files[0] );
    if ( $position == 1 ) {
        unshift @files, $goldfile;
        say "1st file will be $goldfile" unless $opt{silent};
    } else {
        push @files, $goldfile;
        say "2nd file will be $goldfile" unless $opt{silent};
    }
}
if ( $opt{dir2} ) {
    my $dir2file = to_dir2( $files[0] );
    say "2nd file will be $dir2file" unless $opt{silent};
    push @files, $dir2file;
}

# If only one file was specified, and it's a perforce p4 rev, get the current non-revved version
# k file#123
if ( not $files[1] and $files[0] =~ /^(\S+)#(\d+|head|n|next|\+|\-)$/ ) {
    my $nonrevp4file = $1;
    say "2nd file will be $nonrevp4file" unless $opt{silent};
    push @files, $nonrevp4file;
}
d '@files';
# Enable  'k file#1 #2'
my $basefile = '';
d '@files';
my $lastrev;
for my $n ( 0 .. $#files ) {
    if ( $files[$n] =~ /(.*)#(\d+|head|n|next|\+|\-)$/ ) {
        my ( $base, $rev ) = ( $1, $2 );
        if ($base) {
            $basefile = $base;
        } elsif ( $rev =~ /^(n|next|\+)$/ ) {
            $files[$n] = $basefile . '#' . ( $lastrev + 1 );
        } elsif ( $rev =~ /^(\-)$/ ) {
            $files[$n] = $basefile . '#' . ( $lastrev - 1 );
        } else {
            $files[$n] = $basefile . $files[$n];
        }
        $lastrev = $rev;
    }
}
d '@files';

# Test for existence of files and directories
my @dirs;
my $ls = $windows ? 'ls' : 'ls';    # TODO need equivalent of 'ls -l' for windows
for my $file (@files) {
    next if $file =~ m{^//} or $file =~ /#(\d+|head|n|next|\+|\-)$/;
    d "Testing for existence of $file";
    if ( !-e $file ) {
        say "$file not found.  Exiting";
        exit 1;
    }

    # ls -l
    if ( -f $file or -l $file ) {
        print `ls -l $file` if $opt{verbose};
    } elsif ( $opt{nodirs} ) {
        # do nothing
    } elsif ( -d $file ) {
        my $numfiles = countFilesInDirectory($file);
        say "Found $numfiles files in directory $file:";
        print `ls -ld $file` if $opt{verbose};
        push @dirs, $file;
    }
}
if (@dirs) {
    # Comparing two directories, use  tree -s  or  ls -lR  to list contents
    if ( @dirs != @files ) {
        die "ERROR:  Cannot mix files and directories\n";
    }
    @files = ();
    my $count = 1;
    for my $dir (@dirs) {
        my $tmpfile = "/tmp/" . basename($dir) . "_" . $count++;
        open( "TMP", '>', $tmpfile ) or die "ERROR: Cannot open file for writing:  $tmpfile\n\n";
        my $lslr;
        my @lslr;
        my $text;
        if (0) {
            # ls -l
            for my $line (`ls -lR $dir`) {
                # -rw-rw-r--  1 ckoknat hardware   527 Jul 12 12:36 filename
                #12          3456      78        9 10111213141516  1718
                if ( $line =~ /^(\s*)(\S+)(\s+)(\S+)(\s+)(\S+)(\s+)(\S+)(\s+)(\S+)(\s+)(\S+)(\s+)(\S+)(\s+)(\S+)(\s+)(.*)/ ) {
                    $lslr .= "$1$2$3$6$7$8$9$10 $18\n";
                } elsif ( $line =~ m{^total \d+} ) {
                    # print nothing
                } elsif ( $line =~ m{^($dir)[:/](.*)} ) {
                    $lslr .= "$2\n" if $2;
                } else {
                    $lslr .= $line;
                }
            }
        } else {
            # tree -s
            if (1) {
                $text = `tree -s $dir`;
            } else {
                @lslr = `ls -lR $dir`;
                d '@lslr';
                for my $line (@lslr) {
                    d '$line';
                    my @fields = split /\s+/, $line;
                    d '@fields';
                    if ( $line =~ /^d/ ) {
                        $text .= $line;
                    } else {
                        my ( $size, $filename ) = @fields[ 2, 5 ];
                        #$filename =~ s|^$basefile/||;
                        $text .= "$size  $filename\n";
                    }
                }
            }
            d '$text';
        }
        print TMP $text;
        push @files, $tmpfile;
    }
    # end @dirs (comparing directories)
} elsif ( $opt{tartv} ) {
    # Compare tarfiles using tar -tv, and look at the file size
    #     Would also be nice if it do something to each of those files, for example md5sum or -externalPreprocessScript <script>
    #
    # If this option is not used, it will simply gvimdiff the tarballs:
    #     cmpx //ate/patterns/conversion/srmFiles/tv5s/a01/d/tv5s_a01_d.timingdb_cp_jtagbyptst_d_2_std_FUNC_13_1_dir.tar.gz#2 #3 -comments
    my @origFiles = @files;
    @files = ();
    my $count = 1;
    for my $f (@origFiles) {
        my $basefile = basename($f);
        $basefile =~ s/\.tar(\.(gz|bz2|xz))?$//;
        d '$basefile';
        my $tmpfile = "/tmp/" . basename($f) . "_" . $count++;
        d '$tmpfile';
        open( "TMP", '>', $tmpfile ) or die "ERROR: Cannot open file for writing:  $tmpfile\n\n";
        my $zipCat = ext2zipcat($f);
        d '$zipCat';
        die "ERROR:  File $f is tar a tar file" if basename($f) !~ /\.tar/;
        my @tar = `$zipCat $f | tar -tv`;
        d '@tar';
        my $text;

        for my $line ( sort @tar ) {
            my @fields = split /\s+/, $line;
            #if ( $line =~ /^d/ ) {
            #    $text .= $line;
            #} else {
            my ( $size, $filename ) = @fields[ 2, 5 ];
            $filename =~ s|^$basefile/||;
            $text .= "$size  $filename\n";
            #}
        }
        d '$text';
        print TMP $text;
        push @files, $tmpfile;
    }
}

sub decideFieldSeparator {
    my $file = shift;
    my $fieldSeparator;
    if ( defined $opt{fieldSeparator} ) {
        $fieldSeparator = $opt{fieldSeparator};
    } elsif ( $file =~ /\.csv(\.gz)?$/ ) {
        $fieldSeparator = ',';
    } else {
        $fieldSeparator = '\s+';
    }
    d '$fieldSeparator';
    return $fieldSeparator;
}

sub getFieldColumnWidths {
    my @fieldColumnWidths;
    my @files = @_;
    for my $file (@files) {
        my $fieldSeparator = decideFieldSeparator($file);
        my $zipCat         = ext2zipcat($file);
        open( my $F, "$zipCat $file |" ) or die "ERROR: Cannot open file for reading:  $file\n\n";
        while ( my $line = <$F> ) {
            chomp($line);
            my @fields = split /$fieldSeparator/, $line;
            for my $i ( 0 .. $#fields ) {
                if ( !defined $fieldColumnWidths[$i] or length $fields[$i] > $fieldColumnWidths[$i] ) {
                    $fieldColumnWidths[$i] = length $fields[$i];
                }
            }
            d '@fields';
        }
    }
    d '@fieldColumnWidths';
    return @fieldColumnWidths;
}

my @fieldColumnWidths;
if ( $opt{fieldJustify} ) {
    @fieldColumnWidths = getFieldColumnWidths(@files);
}

# Preprocess files
my $globaltmpdir;
if ($windows) {
    $globaltmpdir = tempdir( 'C:\Windows\Temp\k_XXXX', CLEANUP => 0 );
} else {
    # want to keep the directory name relatively short because it appears on top of the kompare window
    $globaltmpdir = tempdir( '/tmp/k_XXXX', CLEANUP => 0 );
}
my $count          = 0;
my @localFiles     = ();    # original files or files immediately after p4 print
my @processedFiles = ();    # files after all processing, gunzipping, etc
for my $f (@files) {
    #LS($f);
    $count++;
    my $tmpfile = sprintf( "%s/%d__%s", $globaltmpdir, $count, basename($f) );
    $tmpfile =~ s{/}{\\}g if $windows;
    $tmpfile =~ s/(\.(gz|bz2|xz))//;
    #my $tmpfile = sprintf( "/tmp/%s_%s_%s_%s", basename($0), $$, basename($f), $count);
    if ($preprocessRequired) {
        push @processedFiles, preprocess_file( $f, { tmpfile => $tmpfile }, $count );
    } else {
        d 'No options used, so no need to preprocess';
        push @processedFiles, $f;
        push @localFiles,     $f;
        #system("ln -s $f $tmpfile");
    }
}
d '@processedFiles $preprocessRequired';

# Check if all processed files are zero size
if ( $preprocessRequired and $opt{verbose} ) {
    my $allProcessedFilesZeroSize = 1;
    for my $file (@processedFiles) {
        print `ls -l $file`;
        if ( -s $file ) {
            #d("File $file has zero size");
            $allProcessedFilesZeroSize = 0;
        }
    }
    if ($allProcessedFilesZeroSize) {
        say "WARNING:  All processed files are zero size!";
        exit 0;
    }
}

# Exit early (after preprocess) for -pponly
if ( $opt{pponly} ) {
    #say "Exiting because only one file was specified\n";
    exit 0;
}

# Exit early (after preprocess)
if ( !defined $files[1] and not $opt{stdout} ) {
    say "Exiting because only one file was specified\n";
    exit 0;
}

# Check if files/directories are identical
my $processedFiles = join " ", @processedFiles;
d '$processedFiles';
say "Comparing your files..." if scalar(@files) == 2 and $difftool ne 'md5sum' and not $opt{silent};
if ( scalar(@files) == 2 and not -d $files[0] and not $opt{stdout} ) {
    d 'doing a diff';
    system("$zipDiff $processedFiles > /dev/null");
    d "Status = $?";
    exit $? >> 8 if $opt{silent} or not $difftool;
    # Check exit status
    if ( $? == 0 and $difftool ne "md5sum" ) {
        d '@files @localFiles @processedFiles';
        chomp( my $status1 = `md5sum $localFiles[0] | cut -d ' ' -f 1` );
        chomp( my $status2 = `md5sum $localFiles[1] | cut -d ' ' -f 1` );
        d '$status1 $status2';
        if ( $status1 ne $status2 ) {
            say "*********************************************************************************";
            say "*  These files are functionally identical, but their md5sums differ.  Exiting.  *";
            say "*********************************************************************************";
            say "$status1  $localFiles[0]";
            say "$status2  $localFiles[1]\n";
        } else {
            say "******************************************";
            say "*  These files are identical.  Exiting.  *";
            say "******************************************\n";
        }
        exit 0;
    }
}

# Run kompare
my $command;
if ( $opt{stdout} ) {
    $command = $windows ? "type $processedFiles" : "cat $processedFiles";
} else {
    $command = "$difftool $processedFiles &";
}
d '$command';
#say "Executing  $command &" unless $opt{silent} or $difftool eq 'md5sum';
say "Executing  $command &" if $opt{verbose};
if ($d) {
    say "Exiting because d = $d\n";
    exit 0;
}
if ( scalar(@files) > 2 and $difftool =~ /^(kompare|tkdiff)$/ ) {
    say "Not running $difftool because it only takes 2 files";
    exit 1;
}
system($command);
if ( $files[0] =~ /\.p[lm]/ and not $opt{perltidy} ) {
    say "You seem to be comparing Perl source files.  You may want to use the -perltidy option next time.";
}
if ( $files[0] =~ /\.binl/ and not $opt{strings} ) {
    say "You seem to be comparing 93k binl files.  You may want to use the -strings option next time to remove the binary characters.";
}
say "";
exit 0;

sub ext2zipcat {
    my $file = shift;
    d '$file';
    $file =~ s/(#(\d+|head|\-|\+))?$//;
    $file =~ s/^.*(\.(gz|bz2|xz))$/$1/;
    $file = '.gz' if !defined $file;
    my %catref = ( '.gz' => 'zcat -f', '.bz2' => 'bzcat -f', '.xz' => 'xzcat -f' );
    my $zipCat = $catref{$file};
    if ( !$zipCat ) {
        # .txt
        if ($windows) {
            $zipCat = 'type';
        } else {
            $zipCat = 'cat';
        }
    }
    d '$zipCat';
    return $zipCat;
}

# my $tmpfile = preprocess_file( $file, { tmpfile => $tmpfile }, $filenum )
sub preprocess_file {
    my ( $file, $ref, $filenum ) = @_;
    d '.';
    d '$file $ref $filenum';
    $file = handlePerforce($file);    # p4 print file in perforce
    push @localFiles, $file;

    my ( $start, $stop );
    if ( $opt{"start$filenum"} ) {
        $start = $opt{"start$filenum"};
    } else {
        $start = $opt{start};
    }
    if ( $opt{"stop$filenum"} ) {
        $stop = $opt{"stop$filenum"};
    } else {
        $stop = $opt{stop};
    }

    my $tmpfile = $ref->{tmpfile} || sprintf( "/tmp/%s_%s_%s", basename($0), $$, basename($file) );
    d '\n$file $tmpfile $count';

    # Handle preprocessing from external preprocessing script or bcpp or perltidy
    my $zipCat = ext2zipcat($file);
    d '$zipCat';
    #say "Decompressing $file" if $zipCat ne 'cat' and not $opt{silent};
    my $F;
    if ( $opt{perleval} or $opt{yaml} or $opt{json} or $opt{subroutineSort} ) {
        my $result;
        if ( $opt{perleval} ) {
            $result = sortYamlPerlJson( $file, 'perleval' );
        } elsif ( $opt{yaml} ) {
            $result = sortYamlPerlJson( $file, 'yaml' );
        } elsif ( $opt{json} ) {
            $result = sortYamlPerlJson( $file, 'json' );
        } elsif ( $opt{subroutineSort} ) {
            $result = sortSubroutines($file);
        } else {
            die "Program bug";
        }
        my $tmpfilePerlEvalEtc = sprintf( "/tmp/%s_%s_%s.yamljson", basename($0), $$, basename($file) );
        open( "TMP2", ">", $tmpfilePerlEvalEtc ) or die "ERROR: Cannot open file for writing:  $tmpfilePerlEvalEtc\n\n";
        print TMP2 $result;
        close TMP2;
        open( $F, "cat $tmpfilePerlEvalEtc |" ) or die "ERROR: Cannot open file for reading:  $tmpfilePerlEvalEtc\n\n";
    } else {
        my $preprocess_pipe = "";
        if ( $opt{externalPreprocessScript} ) {
            $preprocess_pipe = "| $opt{externalPreprocessScript}";
        } elsif ( $opt{bcpp} ) {
            ( my $bcpp_executable = $default{bcpp} ) =~ s/^(\S+).*/$1/;
            if ( ! -x $bcpp_executable ) {
                die "ERROR:  $bcpp_executable not found";
            }
            $preprocess_pipe = "| $default{bcpp}";
        } elsif ( $opt{perltidy} ) {
            ( my $perltidy_executable = $default{perltidy} ) =~ s/^(\S+).*/$1/;
            if ( ! -x $perltidy_executable ) {
                die "ERROR:  $perltidy_executable not found";
            }
            # -st sends output to stdout
            $preprocess_pipe = "| $default{perltidy} -st";
        }
        open( $F, "$zipCat $file $preprocess_pipe |" ) or die "ERROR: Cannot open file for reading:  $file\n\n";
    }
    if ( $opt{verbose} ) {
        say "\n\n\n" if ( $opt{gold} or $opt{above} ) and $opt{diff} ne 'md5sum';  # To visually separate the diffs
        say "Preprocessing $file";
    }
    my $wc = "?";
    $wc = `$zipCat $file | wc -l | cut -d " " -f 1` if $opt{tail};
    d('$wc') if $opt{tail};
    open( my $TMP, "$opt{strings} $opt{sort} $opt{uniq} $opt{fold} > $tmpfile" ) or die "ERROR: Cannot open file for writing:  $tmpfile\n\n";
    my $firstline     = $opt{tail} ? ( $wc - $opt{tail} + 1 ) : -1;
    my $linenum       = 0;
    my $startfound    = 0;
    my $anystartfound = 0;
    my $anystopfound  = 0;
    my $stopfound     = 0;
    $startfound = 1 if $stop  and not $start;
    $stopfound  = 1 if $start and not $stop;
    d( '$startfound', 'nc*' );  # Turn on line numbers and chomp

    while ( my $line = <$F> ) {
        #d '$line';
        $linenum++;
        if ( $linenum > $opt{head} ) {
            d "Ignoring rest of file because of option -head";
            last;
        } elsif ( $stop and $startfound and $line =~ /($stop)/ ) {
            d "Stopping at line $linenum because -stop ($1 =~ $stop):  $line";
            $startfound   = 0;
            $stopfound    = 1;
            $anystopfound = 1;
        } elsif ( $start and not $startfound and $line =~ /($start)/ ) {
            d "Starting at line $linenum because -start ($1 =~ $start):  $line";
            $startfound    = 1;
            $anystartfound = 1;
        } elsif ( ( $start or $stop ) and not $startfound ) {
            d "Because of -start and/or -stop, ignoring line $linenum:  $line";
            next;
        } elsif ( $linenum < $firstline ) {
            d "Ignoring line because of option -tail";
            next;
        } elsif ( $opt{ignore} and $line =~ /$opt{ignore}/ ) {
            d "Ignoring line because of -ignore option ($opt{ignore}):  $line";
            next;
        } elsif ( $opt{grep} and $line !~ /$opt{grep}/ ) {
            d "Bypassing line because it doesn't match -grep option ($opt{grep}):  $line";
            next;
        } else {
        }    # do nothing
             #d '$linenum $line';

        if ( defined $opt{fieldJustify} ) {
            my $fieldSeparator = decideFieldSeparator($file);
            my $newline        = '';
            chomp $line;
            my @fields = split $fieldSeparator, $line;
            for my $i ( 0 .. $#fields ) {
                $newline .= sprintf( "%-$fieldColumnWidths[$i]s$fieldSeparator", $fields[$i] );
            }
            $line = "$newline\n";
        }

        if ( defined $opt{fields} ) {
            my $fieldSeparator = decideFieldSeparator($file);
            chomp($line);
            my @fields = split /$fieldSeparator/, $line;
            d '@fields';
            my $newline = '';
            if ($fieldsNegate) {
                for my $i ( 0 .. $#fields ) {
                    if ( $opt{fields} =~ /^$i\+$/ or $opt{fields} =~ /^$i\+,/ or $opt{fields} =~ /,$i\+,/ or $opt{fields} =~ /$i\+$/ ) {
                        last;
                    }
                    if ( $opt{fields} =~ /^$i\+$/ or $opt{fields} =~ /^$i,/ or $opt{fields} =~ /,$i,/ or $opt{fields} =~ /$i$/ ) {
                        # do nothing
                    } else {
                        $newline .= defined $fields[$i] ? "$fields[$i]  " : "";
                    }
                }
            } else {
                for my $f ( split /,/, $opt{fields} ) {
                    d '$f';
                    if ( $f =~ s/\+$// ) {
                        $newline .= join "  ", @fields[ $f .. $#fields ];
                        last;
                    } else {
                        $newline .= defined $fields[$f] ? "$fields[$f]  " : "";
                    }
                }
            }
            $line = "$newline\n";
        }

        if ( $opt{sub} ) {
            d '$opt{sub}';
            d '\n$line';
            d '\n@sub_keys_ordered';
            d '\n$subtable_ref';
            for my $key (@sub_keys_ordered) {
                #d('$key $subtable_ref->{$key}'); # Global symbol "$key" requires explicit package name at (eval 15) line 1, <F> line 1.
                if ($d) { say "DEBUG preprocess_file:  key = $key    subtable_ref->{$key} = $subtable_ref->{$key}" }
                my $cnt = ( $line =~ s/$key/$subtable_ref->{$key}/g );
                #my $cnt = ($line =~ s/HASH(0x\S+)/$subtable_ref->{$key}/g);
                d("Found $key and replaced with $subtable_ref->{$key} on:  $line") if $cnt;
            }
        }

        if ( $opt{lsl} ) {
            if ( $line =~ /^total \S+$/ ) {
                d "Ignoring line because of -lsl option:  $line";
                next;
            }
            if ( $line =~ /(.*)(\S[-rwx]{9})\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+\s+\S+\s+\S+)(\s+\S.*)/ ) {
                my ( $prefix, $perms, $links, $owner, $group, $size, $datetime, $name ) = ( $1, $2, $3, $4, $5, $6, $7, $8 );
                d "Modifying ls -l line:  $line";
                $line = sprintf( "%sperms links owner group %10d datetime %s\n", $prefix, $size, $name );
            }
        }
        # 'mox1' => HASH(0xa2a540)
        # $fstat = HASH(0x25a5cb0)
        if ( $opt{perldump} ) {
            $line =~ s/((SCALAR|HASH|ARRAY|REF|GLOB|CODE).*\(.*)\n$/$2()\n/g;                                     # Perl
            $line =~ s/ at 0x\S+>/>/g;                                                                            # Python
        }

        if ( $opt{comments} ) {
            $line =~ s{/\*.*}{};                                                                                  # C
            $line =~ s{//.*}{};                                                                                   # C++
            $line =~ s{#.*}{};                                                                                    # Perl
                                                                                                                  # After stripping comments, there are sometimes trailing spaces
            $line =~ s/\s+$//;
            $line .= "\n" if $line =~ /\S/;
        }

        if ( $opt{nowhite} ) {
            $line =~ s/^\s+//g;
            $line =~ s/[ \t]+//g;
            $line =~ s/^\n//g;
        } elsif ( $opt{white} ) {
            $line =~ s/^\s+//;
            $line =~ s/[ |\t]+/ /g;
            $line =~ s/ $//g;
        } else {
        }    # do nothing, continue

        if ( $opt{case} ) {
            $line = lc($line);
        }

        if ( $opt{trim} ) {
            chomp( $line = substr( $line, 0, $opt{trim} ) );
            $line .= "\n";
        }

        #d('\n$line');
        print $TMP $line;
    }
    if ( defined $start and not $anystartfound ) {
        say "WARNING:  Did not find start term '$start' in $tmpfile";
    }
    if ( defined $stop and not $anystopfound ) {
        say "WARNING:  Did not find stop term '$stop' in $tmpfile";
    }
    close $TMP;
    d( '', 'NC' );    # Turn off line numbers and chomp
    return $tmpfile;
}

sub countFilesInDirectory {
    use File::Find;
    my $dir   = shift;
    my $count = 0;
    find( sub { -f && $count++ }, $dir );
    return $count;
}

# $ = read_table_file($filename,$opt{reverse},$opt{regex})
# Reads 2-column table mapping file, returns hash reference
# From chris_scripts/linux/search_replace_table.pl and made more consice
sub read_table_file {
    my ( $table_file, $reverse, $regex ) = @_;
    d '$table_file $reverse $regex';
    my %map;
    say "Reading from table file $table_file";
    my $lineNumber = 0;
    open( my $F, '<', $table_file ) or die "ERROR: Cannot open file for reading:  $table_file\n\n";
    while ( my $line = <$F> ) {
        $lineNumber++;
        #d('$line');

        # __END__
        if ( $line =~ /^__END__$/ ) {
            last;
        }

        # blank line or # comment, but not #!
        if ( $line =~ /^\s*$/ or $line =~ /^\s*#[^!]/ ) {
            # do nothing
        }

        # search_term    replace_term
        # xtals_in       XTAL_SSIN
        elsif ( $line =~ /^\s*(\S+)\s+(.*)\n/ ) {    # Allow nothing for value (replace something with nothing, good for removing newlines)
            my ( $key, $value ) = ( $1, $2 );
            $value = '' if not $value;
            $value =~ s/\s*$//;
            d "table valid line = $line";

            if ($reverse) {
                if ( defined $map{$value} ) {
                    say "ERROR:  Table file $table_file contains 2 entries for $value in the right column!";
                    say "        1st entry was:  $map{$value}  $value";
                    say "        2nd entry was:  $key  $value  on line $lineNumber";
                    say "Exiting.\n";
                    exit 1;
                } else {
                    $value = ( $regex ? $value : quotemeta($value) );
                    d "reverse value = '$value'    key = '$key'";
                    $map{$value} = eval "qq($key)";
                }
            } else {
                if ( defined $map{$key} ) {
                    say "ERROR:  Table file $table_file contains 2 entries for $key in the left column!";
                    say "        1st entry was:  $key  $map{$key}";
                    say "        2nd entry was:  $key  $value  on line $lineNumber";
                    say "Exiting.\n";
                    exit 1;
                } else {
                    $key = ( $regex ? $key : quotemeta($key) );
                    d "key = '$key'    value = '$value'\n";
                    $map{$key} = eval "qq($value)";
                }
            }
        }

        # Unknown
        else {
            print "ERROR:  Did not understand line in config file:  $line";
            exit 1;
        }
    }
    close $F;
    d '%map';
    return \%map;
}

sub handlePerforce {
    # Perforce
    my $file = shift;
    if ( $file =~ /^([^#]+)(#\d+|#head)?$/ and $file !~ m{^//} ) {
        # Resolve symbolic link
        $file = Cwd::abs_path($1) . ( $2 || '' );
    }
    if ( $file =~ /\S+#(\d+|head)$/ or $file =~ m{^//} ) {
        if ( $file =~ /^#(\d+|head)$/ and $file !~ m{^//} ) {
            # Ugly ugly hack to work around p4 "Path '/home/ckoknat/s/releasePatterns.pl' is not under client's root '/home/ate/ptracker'." issue
            # This should work for /ate/scripts and all subdirectories, but it's not foolproof
            my $perforcepath = "";
            if ( Cwd::cwd() =~ m{/(scripts/.*)} ) {
                $perforcepath = "//ate/$1/";
                say "I'm assuming that your file $file is in $perforcepath";
            }
            $file = "$perforcepath$file";
        }
        #my $command1 = "unset P4CONFIG ; cd ; p4 -p p4hw:2001 filelog '$file' | head -n 2 | tail -n 1";
        # Print the filelog info for the most current version
        my $command1 = "p4 filelog '$file' | head -n 2 | tail -n 1";
        d '$command1';
        system($command1);
        my $p4tmpfile = sprintf( "/tmp/%s_%s_%s_p4", basename($0), $$, basename($file) );
        d '$p4tmpfile';
        if ( $p4tmpfile =~ /\.([^\.]+)_p4$/ ) {
            $p4tmpfile =~ s/\.([^\.]+)_p4$/_p4.$1/;    # file.gz_p4 => file_p4.gz
        }
        d '$p4tmpfile';
        #my $command2 = "unset P4CONFIG ; cd ; p4 -p p4hw:2001 print -q '$file' > $p4tmpfile";
        my $command2 = "p4 print -q '$file' > $p4tmpfile";
        if ( -d '/home/ate' ) {
            # We are at NV
            my $pwd = Cwd::cwd();
            d '$pwd';
            $command2 = "cd $pwd; $command2";
        }
        say "Executing  $command2 &" if $opt{verbose};
        system($command2);
        if ( -z $p4tmpfile ) {
            say "ERROR:  p4 print created a file with zero size for $file\nDoes the p4 file exist?\nExiting\n";
            exit 1;
        }
        $file = $p4tmpfile;
    }
    return $file;
}

sub indent {
    my $string = shift;
    $string =~ s/^/      /gm;
    $string =~ s/^\s*//;
    return $string;
}

sub sortYamlPerlJson {
    my ( $file, $type ) = @_;
    d '$file $type';
    open my $fh, '<', $file or die;
    local $/ = undef;
    my $data = <$fh>;
    close $fh;
    d '$data';
    my $ref;

    if ( $type eq 'yaml' ) {
        eval 'use YAML::XS ()';
        #eval 'use YAML::Syck ()';
        if ($@) {
            die "ERROR:  Install YAML::XS from CPAN to use option -yaml";
        } else {
            $ref = YAML::XS::LoadFile($file);
            #$ref = YAML::Syck::LoadFile($file);
            d '$ref';
        }
    } elsif ( $type eq 'perleval' ) {
        $ref = eval($data);
    } elsif ( $type eq 'json' ) {
        eval 'use JSON::XS ()';
        if ($@) {
            die "ERROR:  Install JSON::XS from CPAN to use option -json";
        } else {
            my $json;
            local $/;
            open my $fh, "<", $file;
            $json = <$fh>;
            close $fh;
            $ref = JSON::XS::decode_json($json);
        }
    } else {
        die;
    }
    d '$ref';
    $Data::Dumper::Sortkeys = 1;
    return Dumper($ref);
}

# Written for perl, but could be extended to autodetect perl/python/tcl
# Python may be tricky because there are no curly braces at end, could use def and ignore any comments
sub sortSubroutines {
    my ($file) = @_;
    # subroutines must start and end at beginning of line
    d '$file';
    my %subs;
    my $subroutine = '__MAIN__';
    open( my $F, '<', $file ) or die "ERROR: Cannot open file for reading:  $file\n\n";
    while ( my $line = <$F> ) {
        if ( $line =~ /^(__END__|__DATA__)/ ) {
            last;
        } elsif ( $line =~ /^#/ ) {
            # Ignore any comments at beginning of line, since subroutine descriptions are often immediately before the subroutine
        } elsif ( $line =~ /^\}/ ) {
            $subs{$subroutine} .= $line;
            $subroutine = '__MAIN__';
        } elsif ( $line =~ /^(sub\s+(\S+)\s*\{)/ ) {
            $subroutine = $2;
            $subs{$subroutine} = $line;
        } else {
            $subs{$subroutine} .= $line;
        }
    }
    d '%subs';
    my $result = '';
    for my $sub ( sort keys %subs ) {
        $result .= "$subs{$sub}\n";
    }
    return $result;
}
__END__
